import { type Locator, type Page } from "@playwright/test";
import * as fs from "fs";
import * as path from "path";

interface StepRecord {
  number: number;
  title: string;
  description: string;
  screenshotPath: string;
}

export interface StepOptions {
  waitAfter?: number;
  highlightTarget?: Locator;
}

interface LocaleStrings {
  autoGenerated: (date: string) => string;
  stepPrefix: (num: string) => string;
}

const locales: Record<string, LocaleStrings> = {
  ja: {
    autoGenerated: (date) => `自動生成日: ${date}`,
    stepPrefix: (num) => `手順 ${num}`,
  },
  en: {
    autoGenerated: (date) => `Auto-generated on ${date}`,
    stepPrefix: (num) => `Step ${num}`,
  },
};

const DEFAULT_HIDE_OVERLAY_SELECTORS = [
  "nextjs-portal { display: none !important; }",
  "[data-nextjs-dialog-overlay] { display: none !important; }",
  "[data-nextjs-toast] { display: none !important; }",
];

export interface ScenarioRecorderOptions {
  /** Output locale (default: "ja") */
  locale?: "ja" | "en";
  /**
   * CSS rules to hide framework dev overlays during screenshots.
   * Defaults to Next.js overlay selectors (nextjs-portal, etc.).
   * Pass custom selectors for other frameworks (Nuxt, Vite, etc.).
   */
  hideOverlaySelectors?: string[];
}

export class ScenarioRecorder {
  private page: Page;
  private scenarioName: string;
  private title: string;
  private outputDir: string;
  private steps: StepRecord[] = [];
  private screenshotDir: string;
  private locale: LocaleStrings;
  private hideOverlaySelectors: string[];

  constructor(
    page: Page,
    scenarioName: string,
    title: string,
    outputDir: string,
    options?: ScenarioRecorderOptions
  ) {
    this.page = page;
    this.scenarioName = scenarioName;
    this.title = title;
    this.outputDir = outputDir;
    this.screenshotDir = path.join(outputDir, "screenshots", scenarioName);
    this.locale = locales[options?.locale ?? "ja"];
    this.hideOverlaySelectors =
      options?.hideOverlaySelectors ?? DEFAULT_HIDE_OVERLAY_SELECTORS;
    fs.mkdirSync(this.screenshotDir, { recursive: true });
  }

  async step(
    title: string,
    description: string,
    action: (page: Page) => Promise<void>,
    options?: StepOptions
  ) {
    await action(this.page);

    if (options?.waitAfter) {
      await this.page.waitForTimeout(options.waitAfter);
    }

    await this.page.waitForLoadState("domcontentloaded");

    if (options?.highlightTarget) {
      await this.addHighlight(options.highlightTarget);
    }

    await this.hideDevOverlay();

    const stepNum = this.steps.length + 1;
    const padded = String(stepNum).padStart(2, "0");
    const filename = `step-${padded}.png`;
    const screenshotPath = path.join(this.screenshotDir, filename);

    await this.page.screenshot({ path: screenshotPath, fullPage: false });

    await this.restoreDevOverlay();

    if (options?.highlightTarget) {
      await this.removeHighlight(options.highlightTarget);
    }

    this.steps.push({
      number: stepNum,
      title,
      description,
      screenshotPath: `./screenshots/${this.scenarioName}/${filename}`,
    });
  }

  generateMarkdown() {
    const date = new Date().toISOString().slice(0, 10);
    const l = this.locale;
    const lines: string[] = [
      `# ${this.title}`,
      "",
      `> ${l.autoGenerated(date)}`,
      "",
    ];

    for (const s of this.steps) {
      const padded = String(s.number).padStart(2, "0");
      lines.push(`## ${l.stepPrefix(padded)}: ${s.title}`);
      lines.push("");
      lines.push(s.description);
      lines.push("");
      lines.push(`![${l.stepPrefix(padded)}](${s.screenshotPath})`);
      lines.push("");
    }

    const mdPath = path.join(this.outputDir, `${this.scenarioName}.md`);
    fs.writeFileSync(mdPath, lines.join("\n"), "utf-8");
  }

  private async hideDevOverlay() {
    try {
      const selectors = this.hideOverlaySelectors;
      await this.page.evaluate((css: string[]) => {
        const style = document.createElement("style");
        style.id = "__scenario-hide-dev-overlay";
        style.textContent = css.join("\n");
        document.head.appendChild(style);
      }, selectors);
    } catch {
      // page may not be ready — skip
    }
  }

  private async restoreDevOverlay() {
    try {
      await this.page.evaluate(() => {
        document.getElementById("__scenario-hide-dev-overlay")?.remove();
      });
    } catch {
      // skip
    }
  }

  private async addHighlight(locator: Locator) {
    try {
      const el = await locator.elementHandle({ timeout: 5000 });
      if (el) {
        await el.evaluate((node: HTMLElement) => {
          node.dataset.origOutline = node.style.outline;
          node.style.outline = "3px solid red";
        });
        await el.dispose();
      }
    } catch {
      // element may be hidden or detached — skip
    }
  }

  private async removeHighlight(locator: Locator) {
    try {
      const el = await locator.elementHandle({ timeout: 5000 });
      if (el) {
        await el.evaluate((node: HTMLElement) => {
          node.style.outline = node.dataset.origOutline ?? "";
          delete node.dataset.origOutline;
        });
        await el.dispose();
      }
    } catch {
      // element may be hidden or detached — skip
    }
  }
}
